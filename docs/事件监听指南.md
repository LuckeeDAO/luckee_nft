# Luckee NFT 事件监听指南

## 概述

本文档提供 Luckee NFT 合约事件监听的完整指南，包括使用 Tendermint RPC 和 wasmd tx search 命令监听合约事件的方法，以及前端集成示例。

## 事件类型

### 1. 铸造事件 (Mint Events)

**事件类型**: `wasm-mint`

**事件属性**:
- `action`: "mint"
- `token_id`: NFT ID
- `owner`: 所有者地址
- `kind`: NFT 类型

**示例事件**:
```json
{
  "type": "wasm-mint",
  "attributes": [
    {"key": "action", "value": "mint"},
    {"key": "token_id", "value": "1"},
    {"key": "owner", "value": "luckee1user123..."},
    {"key": "kind", "value": "Clover"}
  ]
}
```

### 2. 合成事件 (Synthesize Events)

**事件类型**: `wasm-synthesize`

**事件属性**:
- `action`: "synthesize"
- `output_token_id`: 输出 NFT ID
- `target`: 目标 NFT 类型
- `inputs_count`: 输入数量

**示例事件**:
```json
{
  "type": "wasm-synthesize",
  "attributes": [
    {"key": "action", "value": "synthesize"},
    {"key": "output_token_id", "value": "3"},
    {"key": "target", "value": "Firefly"},
    {"key": "inputs_count", "value": "2"}
  ]
}
```

### 3. 转移事件 (Transfer Events)

**事件类型**: `wasm-transfer`

**事件属性**:
- `action`: "transfer"
- `token_id`: NFT ID
- `from`: 发送者地址
- `to`: 接收者地址

**示例事件**:
```json
{
  "type": "wasm-transfer",
  "attributes": [
    {"key": "action", "value": "transfer"},
    {"key": "token_id", "value": "1"},
    {"key": "from", "value": "luckee1user1..."},
    {"key": "to", "value": "luckee1user2..."}
  ]
}
```

### 4. 批量铸造事件 (Batch Mint Events)

**事件类型**: `wasm-batch_mint`

**事件属性**:
- `action`: "batch_mint"
- `count`: 铸造数量

**示例事件**:
```json
{
  "type": "wasm-batch_mint",
  "attributes": [
    {"key": "action", "value": "batch_mint"},
    {"key": "count", "value": "5"}
  ]
}
```

### 5. 销毁事件 (Burn Events)

**事件类型**: `wasm-burn`

**事件属性**:
- `action`: "burn"
- `token_id`: NFT ID
- `owner`: 所有者地址

**示例事件**:
```json
{
  "type": "wasm-burn",
  "attributes": [
    {"key": "action", "value": "burn"},
    {"key": "token_id", "value": "1"},
    {"key": "owner", "value": "luckee1user123..."}
  ]
}
```

## 监听方法

### 1. 使用 Tendermint RPC

#### 1.1 WebSocket 连接

```javascript
const WebSocket = require('ws');

// 连接到 Tendermint RPC WebSocket
const ws = new WebSocket('wss://rpc.luckee-testnet.com:443/websocket');

ws.on('open', function open() {
  console.log('Connected to Tendermint RPC');
  
  // 订阅所有交易
  ws.send(JSON.stringify({
    jsonrpc: "2.0",
    id: 1,
    method: "subscribe",
    params: ["tm.event='Tx'"]
  }));
});

ws.on('message', function incoming(data) {
  const message = JSON.parse(data);
  
  if (message.result && message.result.events) {
    const events = message.result.events;
    
    // 检查是否包含我们的合约事件
    if (events['wasm._contract_address']) {
      const contractAddress = events['wasm._contract_address'][0];
      
      if (contractAddress === 'luckee1contract...') {
        console.log('Luckee NFT Contract Event:', events);
        
        // 解析事件
        parseContractEvents(events);
      }
    }
  }
});

function parseContractEvents(events) {
  // 解析铸造事件
  if (events['wasm.action'] && events['wasm.action'][0] === 'mint') {
    const tokenId = events['wasm.token_id'][0];
    const owner = events['wasm.owner'][0];
    const kind = events['wasm.kind'][0];
    
    console.log(`NFT Minted: ID=${tokenId}, Owner=${owner}, Kind=${kind}`);
  }
  
  // 解析合成事件
  if (events['wasm.action'] && events['wasm.action'][0] === 'synthesize') {
    const outputTokenId = events['wasm.output_token_id'][0];
    const target = events['wasm.target'][0];
    const inputsCount = events['wasm.inputs_count'][0];
    
    console.log(`NFT Synthesized: Output=${outputTokenId}, Target=${target}, Inputs=${inputsCount}`);
  }
}
```

#### 1.2 HTTP 查询

```bash
#!/bin/bash
# 查询最近的合约事件

CONTRACT_ADDRESS="luckee1contract..."
RPC_ENDPOINT="https://rpc.luckee-testnet.com:443"

# 查询最近的交易
curl -X POST "$RPC_ENDPOINT" \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "id": 1,
    "method": "tx_search",
    "params": {
      "query": "wasm._contract_address='$CONTRACT_ADDRESS'",
      "prove": false,
      "page": 1,
      "per_page": 10,
      "order_by": "desc"
    }
  }' | jq '.result.txs[] | {
    height: .height,
    txhash: .hash,
    events: .result.events
  }'
```

### 2. 使用 wasmd tx search

#### 2.1 基本查询

```bash
#!/bin/bash
# 使用 wasmd 查询合约事件

CONTRACT_ADDRESS="luckee1contract..."
NODE="https://rpc.luckee-testnet.com:443"

# 查询所有合约事件
wasmd query txs \
  --events "wasm._contract_address='$CONTRACT_ADDRESS'" \
  --node "$NODE" \
  --limit 10

# 查询特定事件类型
wasmd query txs \
  --events "wasm._contract_address='$CONTRACT_ADDRESS'&wasm.action='mint'" \
  --node "$NODE" \
  --limit 10

# 查询特定用户的铸造事件
wasmd query txs \
  --events "wasm._contract_address='$CONTRACT_ADDRESS'&wasm.action='mint'&wasm.owner='luckee1user123...'" \
  --node "$NODE" \
  --limit 10
```

#### 2.2 高级查询

```bash
#!/bin/bash
# 高级事件查询脚本

CONTRACT_ADDRESS="luckee1contract..."
NODE="https://rpc.luckee-testnet.com:443"

# 查询最近1小时的铸造事件
START_TIME=$(date -d '1 hour ago' -u +%Y-%m-%dT%H:%M:%SZ)
wasmd query txs \
  --events "wasm._contract_address='$CONTRACT_ADDRESS'&wasm.action='mint'" \
  --node "$NODE" \
  --limit 100 \
  --output json | jq '.txs[] | select(.timestamp > "'$START_TIME'") | {
    timestamp: .timestamp,
    txhash: .txhash,
    events: .events
  }'

# 查询特定NFT类型的事件
wasmd query txs \
  --events "wasm._contract_address='$CONTRACT_ADDRESS'&wasm.kind='Clover'" \
  --node "$NODE" \
  --limit 50
```

### 3. 实时监听脚本

```bash
#!/bin/bash
# 实时事件监听脚本

CONTRACT_ADDRESS="luckee1contract..."
NODE="https://rpc.luckee-testnet.com:443"
LAST_HEIGHT=0

echo "开始监听 Luckee NFT 合约事件..."
echo "合约地址: $CONTRACT_ADDRESS"
echo "节点: $NODE"
echo ""

while true; do
  # 获取最新区块高度
  CURRENT_HEIGHT=$(wasmd query block --node "$NODE" --output json | jq -r '.block.header.height')
  
  if [ "$CURRENT_HEIGHT" -gt "$LAST_HEIGHT" ]; then
    # 查询新高度的事件
    wasmd query txs \
      --events "wasm._contract_address='$CONTRACT_ADDRESS'" \
      --node "$NODE" \
      --height "$CURRENT_HEIGHT" \
      --output json | jq -r '.txs[]? | {
        height: .height,
        txhash: .txhash,
        timestamp: .timestamp,
        events: .events
      }'
    
    LAST_HEIGHT=$CURRENT_HEIGHT
  fi
  
  sleep 5
done
```

## 前端集成示例

### 1. React Hook 示例

```javascript
import { useState, useEffect } from 'react';

// 事件监听 Hook
export function useContractEvents(contractAddress, rpcEndpoint) {
  const [events, setEvents] = useState([]);
  const [isConnected, setIsConnected] = useState(false);
  const [ws, setWs] = useState(null);

  useEffect(() => {
    const wsUrl = rpcEndpoint.replace('https://', 'wss://').replace('http://', 'ws://') + '/websocket';
    const websocket = new WebSocket(wsUrl);

    websocket.onopen = () => {
      console.log('WebSocket connected');
      setIsConnected(true);
      
      // 订阅交易事件
      websocket.send(JSON.stringify({
        jsonrpc: "2.0",
        id: 1,
        method: "subscribe",
        params: ["tm.event='Tx'"]
      }));
    };

    websocket.onmessage = (event) => {
      const data = JSON.parse(event.data);
      
      if (data.result && data.result.events) {
        const events = data.result.events;
        
        // 检查是否包含我们的合约事件
        if (events['wasm._contract_address'] && 
            events['wasm._contract_address'][0] === contractAddress) {
          
          const eventData = {
            action: events['wasm.action']?.[0],
            tokenId: events['wasm.token_id']?.[0],
            owner: events['wasm.owner']?.[0],
            kind: events['wasm.kind']?.[0],
            timestamp: new Date().toISOString(),
            txHash: data.result.tx_hash
          };
          
          setEvents(prev => [eventData, ...prev.slice(0, 99)]); // 保留最近100个事件
        }
      }
    };

    websocket.onclose = () => {
      console.log('WebSocket disconnected');
      setIsConnected(false);
    };

    websocket.onerror = (error) => {
      console.error('WebSocket error:', error);
      setIsConnected(false);
    };

    setWs(websocket);

    return () => {
      websocket.close();
    };
  }, [contractAddress, rpcEndpoint]);

  return { events, isConnected };
}

// 使用示例
export function EventMonitor({ contractAddress, rpcEndpoint }) {
  const { events, isConnected } = useContractEvents(contractAddress, rpcEndpoint);

  return (
    <div>
      <h3>合约事件监控</h3>
      <p>连接状态: {isConnected ? '已连接' : '未连接'}</p>
      
      <div>
        {events.map((event, index) => (
          <div key={index} className="event-item">
            <strong>{event.action}</strong>
            {event.tokenId && <span> - Token ID: {event.tokenId}</span>}
            {event.owner && <span> - Owner: {event.owner}</span>}
            {event.kind && <span> - Kind: {event.kind}</span>}
            <br />
            <small>{event.timestamp}</small>
          </div>
        ))}
      </div>
    </div>
  );
}
```

### 2. Vue.js 组合式 API 示例

```javascript
import { ref, onMounted, onUnmounted } from 'vue';

export function useContractEvents(contractAddress, rpcEndpoint) {
  const events = ref([]);
  const isConnected = ref(false);
  let ws = null;

  const connect = () => {
    const wsUrl = rpcEndpoint.replace('https://', 'wss://').replace('http://', 'ws://') + '/websocket';
    ws = new WebSocket(wsUrl);

    ws.onopen = () => {
      console.log('WebSocket connected');
      isConnected.value = true;
      
      ws.send(JSON.stringify({
        jsonrpc: "2.0",
        id: 1,
        method: "subscribe",
        params: ["tm.event='Tx'"]
      }));
    };

    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      
      if (data.result && data.result.events) {
        const eventData = data.result.events;
        
        if (eventData['wasm._contract_address'] && 
            eventData['wasm._contract_address'][0] === contractAddress) {
          
          const event = {
            action: eventData['wasm.action']?.[0],
            tokenId: eventData['wasm.token_id']?.[0],
            owner: eventData['wasm.owner']?.[0],
            kind: eventData['wasm.kind']?.[0],
            timestamp: new Date().toISOString(),
            txHash: data.result.tx_hash
          };
          
          events.value.unshift(event);
          if (events.value.length > 100) {
            events.value = events.value.slice(0, 100);
          }
        }
      }
    };

    ws.onclose = () => {
      console.log('WebSocket disconnected');
      isConnected.value = false;
    };

    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
      isConnected.value = false;
    };
  };

  const disconnect = () => {
    if (ws) {
      ws.close();
      ws = null;
    }
  };

  onMounted(() => {
    connect();
  });

  onUnmounted(() => {
    disconnect();
  });

  return {
    events,
    isConnected,
    connect,
    disconnect
  };
}
```

## 事件解析工具

### 1. 事件解析器

```javascript
// 事件解析工具类
export class ContractEventParser {
  constructor(contractAddress) {
    this.contractAddress = contractAddress;
  }

  parseEvent(events) {
    if (!events['wasm._contract_address'] || 
        events['wasm._contract_address'][0] !== this.contractAddress) {
      return null;
    }

    const action = events['wasm.action']?.[0];
    
    switch (action) {
      case 'mint':
        return this.parseMintEvent(events);
      case 'synthesize':
        return this.parseSynthesizeEvent(events);
      case 'transfer':
        return this.parseTransferEvent(events);
      case 'burn':
        return this.parseBurnEvent(events);
      case 'batch_mint':
        return this.parseBatchMintEvent(events);
      default:
        return {
          type: 'unknown',
          action,
          raw: events
        };
    }
  }

  parseMintEvent(events) {
    return {
      type: 'mint',
      tokenId: events['wasm.token_id']?.[0],
      owner: events['wasm.owner']?.[0],
      kind: events['wasm.kind']?.[0],
      timestamp: new Date().toISOString()
    };
  }

  parseSynthesizeEvent(events) {
    return {
      type: 'synthesize',
      outputTokenId: events['wasm.output_token_id']?.[0],
      target: events['wasm.target']?.[0],
      inputsCount: events['wasm.inputs_count']?.[0],
      timestamp: new Date().toISOString()
    };
  }

  parseTransferEvent(events) {
    return {
      type: 'transfer',
      tokenId: events['wasm.token_id']?.[0],
      from: events['wasm.from']?.[0],
      to: events['wasm.to']?.[0],
      timestamp: new Date().toISOString()
    };
  }

  parseBurnEvent(events) {
    return {
      type: 'burn',
      tokenId: events['wasm.token_id']?.[0],
      owner: events['wasm.owner']?.[0],
      timestamp: new Date().toISOString()
    };
  }

  parseBatchMintEvent(events) {
    return {
      type: 'batch_mint',
      count: events['wasm.count']?.[0],
      timestamp: new Date().toISOString()
    };
  }
}
```

### 2. 事件过滤器

```javascript
// 事件过滤器
export class EventFilter {
  constructor() {
    this.filters = [];
  }

  addFilter(filter) {
    this.filters.push(filter);
    return this;
  }

  filter(events) {
    return this.filters.every(filter => filter(events));
  }

  // 按事件类型过滤
  byAction(action) {
    return this.addFilter(events => events['wasm.action']?.[0] === action);
  }

  // 按NFT类型过滤
  byKind(kind) {
    return this.addFilter(events => events['wasm.kind']?.[0] === kind);
  }

  // 按所有者过滤
  byOwner(owner) {
    return this.addFilter(events => events['wasm.owner']?.[0] === owner);
  }

  // 按时间范围过滤
  byTimeRange(startTime, endTime) {
    return this.addFilter(events => {
      const timestamp = events['wasm.timestamp']?.[0];
      if (!timestamp) return false;
      
      const eventTime = new Date(timestamp).getTime();
      return eventTime >= startTime && eventTime <= endTime;
    });
  }
}
```

## 监控最佳实践

### 1. 错误处理

```javascript
// 带错误处理的事件监听器
export class RobustEventMonitor {
  constructor(contractAddress, rpcEndpoint) {
    this.contractAddress = contractAddress;
    this.rpcEndpoint = rpcEndpoint;
    this.ws = null;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
    this.reconnectDelay = 1000;
  }

  connect() {
    try {
      const wsUrl = this.rpcEndpoint.replace('https://', 'wss://').replace('http://', 'ws://') + '/websocket';
      this.ws = new WebSocket(wsUrl);

      this.ws.onopen = () => {
        console.log('WebSocket connected');
        this.reconnectAttempts = 0;
        this.onConnected();
      };

      this.ws.onmessage = (event) => {
        try {
          this.onMessage(event);
        } catch (error) {
          console.error('Error processing message:', error);
        }
      };

      this.ws.onclose = () => {
        console.log('WebSocket disconnected');
        this.onDisconnected();
        this.attemptReconnect();
      };

      this.ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        this.onError(error);
      };

    } catch (error) {
      console.error('Failed to create WebSocket connection:', error);
      this.attemptReconnect();
    }
  }

  attemptReconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);
      
      setTimeout(() => {
        this.connect();
      }, this.reconnectDelay * this.reconnectAttempts);
    } else {
      console.error('Max reconnection attempts reached');
      this.onMaxReconnectAttemptsReached();
    }
  }

  onConnected() {
    // 子类实现
  }

  onMessage(event) {
    // 子类实现
  }

  onDisconnected() {
    // 子类实现
  }

  onError(error) {
    // 子类实现
  }

  onMaxReconnectAttemptsReached() {
    // 子类实现
  }

  disconnect() {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }
}
```

### 2. 性能优化

```javascript
// 性能优化的事件监听器
export class OptimizedEventMonitor extends RobustEventMonitor {
  constructor(contractAddress, rpcEndpoint) {
    super(contractAddress, rpcEndpoint);
    this.eventBuffer = [];
    this.bufferSize = 100;
    this.flushInterval = 1000; // 1秒
    this.lastFlush = Date.now();
  }

  onMessage(event) {
    const data = JSON.parse(event.data);
    
    if (data.result && data.result.events) {
      const events = data.result.events;
      
      if (events['wasm._contract_address'] && 
          events['wasm._contract_address'][0] === this.contractAddress) {
        
        this.eventBuffer.push({
          ...events,
          timestamp: Date.now(),
          txHash: data.result.tx_hash
        });

        // 检查是否需要刷新缓冲区
        if (this.eventBuffer.length >= this.bufferSize || 
            Date.now() - this.lastFlush >= this.flushInterval) {
          this.flushBuffer();
        }
      }
    }
  }

  flushBuffer() {
    if (this.eventBuffer.length > 0) {
      this.onEventsBatch(this.eventBuffer);
      this.eventBuffer = [];
      this.lastFlush = Date.now();
    }
  }

  onEventsBatch(events) {
    // 子类实现批量事件处理
  }
}
```

## 总结

本指南提供了完整的 Luckee NFT 合约事件监听解决方案，包括：

1. **事件类型定义**: 详细说明各种事件类型和属性
2. **监听方法**: Tendermint RPC 和 wasmd 命令的使用方法
3. **前端集成**: React 和 Vue.js 的集成示例
4. **工具类**: 事件解析器和过滤器
5. **最佳实践**: 错误处理和性能优化

通过这些工具和方法，开发者可以轻松监听和解析 Luckee NFT 合约的各种事件，实现实时监控和用户界面更新。

---

**文档版本**: 1.0.0  
**最后更新**: 2024年12月  
**维护团队**: Luckee DAO
